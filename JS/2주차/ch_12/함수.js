console.log('helloworld');
// ch.12 함수

// 프로그래밍 언어의 함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
// 함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value) 이라 한다.
// 함수는 함수 정의(function definition)를 통해 생성한다.

// 함수를 사용하는 이유
// - 코드의 재사용
// - 유지보수의 편의성
// - 코드의 신뢰성
// - 코드의 가독성

// 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
// 일반 객체에는 함수 객체만의 고유한 프로퍼티를 갖는다.
// 함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징이다.

// 함수 정의
// - 함수 선언문
// function add(x, y) {
//     return x + y;
// }

// - 함수 표현식
// var add = function (x, y) {
//     return x + y;
// };

// - Function 생성자 함수
// var add = new Function('x', 'y', 'return x+y');
// - 화살표 함수
// var add = (x, y) => x + y;

// 모든 함수 정의 방식은 함수를 정의한다는 면에서 동일하다. 그러나 미요하지만 중요한 차이가 있다.


// 함수 선언문
// function add(x,y){
//     return x+y;
// }
// 함수 선언문은 함수 리터럴과 형태가 동일함. 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없음.
// 함수 선언문은 표현식이 아닌 문이다.
// 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함.
// 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출함.

// 함수 표현식
// var add = function (x,y){
//     return x+y;
// };
// 자바스크립트의 함수는 일급 객체이다.
// 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.

// 자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보이지만,
//함수 선언문과 함수 표현식이 정확히 동일하게 동작하지는 않음.
// 함수 선언문은 표현식이 아닌 문. 함수 표현식은 표현식인 문. 따라서 미묘하지만 중요한 차이가 있다.


// 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
// 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 할 수 없다.
// 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문
// console.log(add);   //  [Function: add]
// console.dir(sub);   //  undefined
//
// console.log(add(2,6));  // 8
// console.log(sub(2,6));  // TypeError: sub is not a function
//
// //함수 선언문
// function add(x,y){
//     return x+y;
// }
// var sub = function (x,y){
//     return x-y;
// };

///////////////////
// 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성됨.
// 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(function hoisting)이라 함.

// 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생함.
// 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨.
///////////////////

// Function 생성자 함수
// 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지 않다. Function 생성자 함수로 생성한 함수는 클로저(closure)를 생성하지 않는등,
// 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작함.

// 화살표 함수
// 화살표 함수는 항상 익명 함수로 정의함
// const add = (x, y) => x+y;
// console.log(add(2,5));
// 기존의 함수 선언문 또는 함수 표현식을 완전히 대체하기 위해 디자인된것은 아니다.
// 화살표 함수는 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화 되어 있다.

// 함수 호출
// 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음. 인수가 부족해서 인수가 할당되지 않는 매개변수의 값은 undefined 다. 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다. 
// 초과된 인수는 그냥 버려지는 것이 아닌 arguments 객체의 프로퍼티로 보관됨
// function add(x,y){
//     console.log(arguments); // [Arguments] { '0': 2, '1': 3, '2': 4 }
//     return x+y;
// }
//
// console.log(add(2,3,4));    // 5

// 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
// 자바스크립트는 동적타입언어이기 때문에 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

// 이상적인 함수는 한가지 일만 해야 하며 가급적 작게 만들어야 한다.


// 반환문
// 함수는 return 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환(return) 할 수 있다
// 함수 호출은 표현식이다.

// 순수함수
// - 외부상태를 변경하지 않고 외부상태에 의존하지도 않는 함수
// - 순수 함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 함.

// 즉시 실행 함수
// - 함수 정의와 동시에 즉시 호출되는 함수. 즉시실행함수(Immediately Invoked Function Expression)
// - 한번만 호출되며 다시 호출할수 없다
// (function (){
//     var a = 3;
//     var b = 5;
//     console.log(a*b);
//     return a*b;
// }());

// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.
// var res = (function (){
//     var a = 3;
//     var b = 5;
//     return a*b;
// }());
// console.log(res);// 15
// console.log(res);// 15
//
// res = (function (a,b){
//     return a*b;
// }(4,5));
// console.log(res);// 20

// 재귀함수
// - 재귀함수는 반복되는 처리를 위해 사용함.
// - 재귀함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있음.
// - 재귀함수는 자신을 무한 재귀 호출하므로 멈출 수 있는 탈출 조건을 반드시 만들어야 한다. 그렇지 않으면 무한 호출되어 스택 오버플로 에러가 발생한다.

// 중첩함수
// - 함수 내부에 정의된 함수를 중첩함수(nested function) 또는 내부 함수(inner function)라 한다.
// - 중첩함수를 포함하는 함수는 외부 함수(outer function)라 부른다.
// function outer(){
//     var x = 1;
//    
//     // 중첩 함수
//     function inner(){
//         var y = 2;
//         console.log(x+y);
//     }
//     inner();
// }
// outer();
// 호이스팅으로 인해 혼란이 발생할 수 있으므로 if문이나 for문 등의 코드 블록에서 함수선언문을 통해 함수를 정의하는 것은 바람직하지 않음

// 콜백함수
// - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수(callback function)이라고 함.
// - 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차함수(higher-order function)이라고 함.
// 고차함수는 콜백 함수를 자신의 일부분으로 합성함.
// 고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출함. --> 콜백함수는 고차함수에 의해 호출되며 이 때 고차함수는 필요에 따라 콜백함수에 인수를 전달할 수 있다.
// var res = [1, 2, 3].map(function (i) {
//     return i * 2;
// });
// console.log(res);

// 순수함수와 비순수함수
// - 순수함수: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수효과가 없는 함수
// - 비순수함수: 외부 상태에 의존하거나 외부 상태를 변경하는, 부수효과가 있는 함수.

// var count = 0;
// // 순수함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환함
// function increase(n){
//     return ++n;
// }
// count = increase(count);
// count = increase(count);
// console.log(count); // 2

// var count = 0;
// // 비순수함수. 외부상태에 의존하여 외부 상태를 변경
// function increase() {
//     return ++count;
// }
// increase();
// increase();
// console.log(count);